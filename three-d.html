<!doctype html>
<html lang="en">
  <head>
    <title>SVG Pseudo-3D Rendering</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="style.css" rel="stylesheet" />
    <link href="three-d.css" rel="stylesheet" />
    <link rel="icon" href="favicon.svg" type="image/svg+xml" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Libertinus+Math&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <h1>SVG Pseudo-3D Rendering</h1>
      <div class="subhead"><a href="index.html">Home</a></div>
    </header>
    <main>
      <section>
        <p>
          I kept wanting to expore how to turn a 3D scene into lines that can be plotted by a pen
          plotter. So here goes. I don't think I'm inventing anything new here, but I want to
          understand how it works.
        </p>
      </section>
      <section>
        <h2 id="simple-cube-wireframe">
          <a class="anchor" href="#simple-cube-wireframe"></a>
          <span>Simple Cube Wireframe</span>
        </h2>
        <div class="flex-container">
          <div>
            <p>
              Let's start by drawing a cube which rotates around its axes and plotting the corner
              points along with the wireframe lines between those points. Consider this the initial
              step in the project. Behind the scenes this involves a lot of math, including, but not
              limited to, matrix multiplication in 2-, 3- and 4-D (the latter to use Homogeneous
              coordinates), both parallel and projective camera transforms. I've already set up all
              this math once before for my
              <a href="https://github.com/libeks/go-scene-renderer">CPU-based 3D renderer</a>, so
              most of the work was to adapt the go code to JavaScript.
            </p>
            <p>
              Critically, I want to accomplish a 3D look using only SVG elements, which is
              inherently a 2D display technoloyg. In fact, I will also ignore SVG render order for
              occlusion, and will do all of the math myself. So for the display to the right, I am
              doing the math in 3D, but rendering SVG lines and points in 2D.
            </p>
            <p>
              A funny side-effect is that if you look at the animation long enough, your brain can
              flip its direction of perception, making it seem that the deeper points appear more
              shallow, which is kinda fun. This is inherent to wireframe-only rendering. I'll start
              dealing with occlusion in the next section.
            </p>
          </div>
          <figure id="cube-wireframe" class="float-right small">
            <svg viewBox="0 0 600 300">
              <three-d-scene
                :frame="t"
                :scene="scene"
                :screen="screen"
                show-points
                show-wireframe
              />
            </svg>
            <figcaption>
              The eight corners of a cube rotating around its vertical axis.<br />t={{t}}
              <div class="button" @click="active = !active">{{active ? 'Pause' : 'Resume'}}</div>
              <div>
                <input type="radio" id="one" value="parallel" v-model="camera" />
                <label for="one">Isometric</label>

                <input type="radio" id="two" value="projective" v-model="camera" />
                <label for="two">Projective</label>
              </div>
            </figcaption>
          </figure>
        </div>
      </section>
      <section>
        <h2 id="hiding-invisible-faces">
          <a class="anchor" href="#hiding-invisible-faces"></a>
          <span>Hiding Invisible Faces</span>
        </h2>
        <div class="flex-container">
          <div>
            <p>
              Next, I want to start drawing faces. Notice that some faces are pointing away from the
              camera, and I can use the vertex order of each polygon to decide which direction that
              face is pointing. The rule I came up is that a face is facing the camera only if its
              vertexes appear in a counter-clockwise order. In other words, a face points in the
              same direction as the cross product between any subsequent edges of that face,
              presented in counter-clockwise order.
            </p>
            <p>
              The resulting render of a cube now looks stunning, I only get the faces that are
              visible, the other faces are not even attempted to be rendered. However, the choice to
              display a cube hides a bigger issue with this algorithm - occlusion.
            </p>
          </div>
          <figure id="cube-faces" class="float-right small">
            <svg viewBox="0 0 600 300">
              <three-d-scene :frame="t" :scene="scene" :screen="screen" show-transparent-faces />
            </svg>
            <figcaption>
              The same cube, showing only faces that point towards the camera.<br />t={{t}}
              <div class="button" @click="active = !active">{{active ? 'Pause' : 'Resume'}}</div>
              <div>
                <input type="radio" id="cube-faces-isometric" value="parallel" v-model="camera" />
                <label for="cube-faces-isometric">Isometric</label>

                <input
                  type="radio"
                  id="cube-faces-projective"
                  value="projective"
                  v-model="camera"
                />
                <label for="cube-faces-projective">Projective</label>
              </div>
            </figcaption>
          </figure>
        </div>
      </section>
      <section>
        <h2 id="face-occlusion">
          <a class="anchor" href="#face-occlusion"></a>
          <span>Face Occlusion</span>
        </h2>
        <div class="flex-container">
          <p>
            A cube is simple in that no visible face occludes any other face. Let's add another
            object to the scene to be rendered behind the cube. With the current approach, faces
            from the two objects are rendered on top of each other, occlusion is completely ignored.
            Time to work on a solution.
          </p>
          <figure id="cube-rectangle-transparent" class="float-right small">
            <svg viewBox="0 0 600 300">
              <three-d-scene :frame="t" :scene="scene" :screen="screen" show-transparent-faces />
            </svg>
            <figcaption>
              A cube and a rectangular prism rendered in the same scene.<br />t={{t}}
              <div class="button" @click="active = !active">{{active ? 'Pause' : 'Resume'}}</div>
              <div>
                <input
                  type="radio"
                  id="cube-rect-transparent-isometric"
                  value="parallel"
                  v-model="camera"
                />
                <label for="cube-rect-transparent-isometric">Isometric</label>

                <input
                  type="radio"
                  id="ccube-rect-transparent-projective"
                  value="projective"
                  v-model="camera"
                />
                <label for="cube-rect-transparent-projective">Projective</label>
              </div>
            </figcaption>
          </figure>
        </div>
        <div class="flex-container">
          <p>
            I have to start looking at whether the projected edge line segments intersect. If so,
            I'll decide which line segment is in front of the other one, and use this information to
            deduce the points defining the polygon from the camera's viewpoint. There are several
            edge cases to consider. A face can end up being split into multiple display polygons. A
            face can be obstructed my multiple other faces, and finally, a face polygon can
            completely contain another face's polygon. My algorithm has to account for all of these.
          </p>
          <figure id="cube-rectangle-occlusion" class="float-right small">
            <svg viewBox="0 0 600 300">
              <three-d-scene
                :frame="t"
                :scene="scene"
                :screen="screen"
                show-intersection-points
                show-visible-lines
              />
            </svg>
            <figcaption>
              For each face, compute the line segments that are fully visible from the camera,
              hiding the segments that are obscured. The points of interest are shown here.<br />t={{t}}
              <div class="button" @click="active = !active">{{active ? 'Pause' : 'Resume'}}</div>
              <div>
                <input
                  type="radio"
                  id="cube-rect-occlusion-isometric"
                  value="parallel"
                  v-model="camera"
                />
                <label for="cube-rect-occlusion-isometric">Isometric</label>

                <input
                  type="radio"
                  id="cube-rect-occlusion-projective"
                  value="projective"
                  v-model="camera"
                />
                <label for="cube-rect-occlusion-projective">Projective</label>
              </div>
            </figcaption>
          </figure>
        </div>
      </section>
    </main>
    <footer>
      <p>No LLMs were consulted in the making of this site.</p>
      <p>© 2026 Jānis Lībeks</p>
    </footer>
    <script type="module">
      const { createApp, ref, defineComponent } = Vue
      import { threeDScene } from './js/3d.js'
      import { Scene3D, Object3D, StaticTransform, ParameterizedTransform } from './js/scene3d.js'
      import { Point3D, Vector3D } from './js/geometry3D.js'
      import { TranslateHomo, RotateXHomo, RotateYHomo, RotateZHomo } from './js/geometryHomo.js'
      import { Screen, ProjectiveCamera, IsometricCamera } from './js/pixelSpace.js'

      // cube of side length 200 centered around the origin
      const cube = new Object3D(
        // faces
        [
          { points: [0, 3, 2, 1], color: 'red' },
          { points: [0, 1, 5, 4], color: 'yellow' },
          { points: [0, 4, 7, 3], color: 'blue' },
          { points: [2, 3, 7, 6], color: 'orange' },
          { points: [1, 2, 6, 5], color: 'cyan' },
          { points: [4, 5, 6, 7], color: 'green' },
        ],
        // points
        [
          new Point3D(-100, -100, 100), // 0
          new Point3D(-100, 100, 100), // 1
          new Point3D(100, 100, 100), // 2
          new Point3D(100, -100, 100), // 3
          new Point3D(-100, -100, -100), // 4
          new Point3D(-100, 100, -100), // 5
          new Point3D(100, 100, -100), // 6
          new Point3D(100, -100, -100), // 7
        ],
      )
        .withTransform(
          new ParameterizedTransform((t) =>
            RotateZHomo(t / 20)
              .matrixMult(RotateYHomo(t / 10))
              .matrixMult(RotateXHomo(t / 50)),
          ),
        )
        .withTransform(new StaticTransform(TranslateHomo(new Vector3D(0, 0, 300))))

      const farRectangle = new Object3D(
        // faces
        [
          { points: [0, 3, 2, 1], color: 'red' },
          { points: [0, 1, 5, 4], color: 'yellow' },
          { points: [0, 4, 7, 3], color: 'blue' },
          { points: [2, 3, 7, 6], color: 'orange' },
          { points: [1, 2, 6, 5], color: 'cyan' },
          { points: [4, 5, 6, 7], color: 'green' },
        ],
        // points
        [
          new Point3D(-1000, -100, 100), // 0
          new Point3D(-1000, 100, 100), // 1
          new Point3D(1000, 100, 100), // 2
          new Point3D(1000, -100, 100), // 3
          new Point3D(-1000, -100, -100), // 4
          new Point3D(-1000, 100, -100), // 5
          new Point3D(1000, 100, -100), // 6
          new Point3D(1000, -100, -100), // 7
        ],
      )
        .withTransform(new ParameterizedTransform((t) => RotateXHomo(t / 5)))
        .withTransform(new StaticTransform(TranslateHomo(new Vector3D(0, 0, 1000))))

      const faceA = new Object3D(
        // faces
        [
          // { points: [0, 3, 2, 1], color: 'red' },
          // { points: [0, 1, 5, 4], color: 'yellow' },
          // { points: [0, 4, 7, 3], color: 'blue' },
          { points: [2, 3, 6], color: 'orange' },
          // { points: [1, 2, 6, 5], color: 'cyan' },
          // { points: [4, 5, 6, 7], color: 'green' },
        ],
        // points
        [
          new Point3D(-100, -100, 100), // 0
          new Point3D(-100, 100, 100), // 1
          new Point3D(100, 100, 100), // 2
          new Point3D(100, -100, 100), // 3
          new Point3D(-100, -100, -100), // 4
          new Point3D(-100, 100, -100), // 5
          new Point3D(100, 100, -100), // 6
          new Point3D(100, -100, -100), // 7
        ],
      )
        .withTransform(
          new ParameterizedTransform((t) =>
            RotateZHomo(t / 20)
              .matrixMult(RotateYHomo(t / 10))
              .matrixMult(RotateXHomo(t / 50)),
          ),
        )
        .withTransform(new StaticTransform(TranslateHomo(new Vector3D(0, 0, 300))))

      const faceB = new Object3D(
        // faces
        [{ points: [4, 5, 6, 7], color: 'green' }],
        // points
        [
          new Point3D(-1000, -100, 100), // 0
          new Point3D(-1000, 100, 100), // 1
          new Point3D(1000, 100, 100), // 2
          new Point3D(1000, -100, 100), // 3
          new Point3D(-1000, -100, -100), // 4
          new Point3D(-1000, 100, -100), // 5
          new Point3D(1000, 100, -100), // 6
          new Point3D(1000, -100, -100), // 7
        ],
      )
        .withTransform(new ParameterizedTransform((t) => RotateXHomo(t / 5)))
        .withTransform(new StaticTransform(TranslateHomo(new Vector3D(0, 0, 1000))))

      createApp({
        data() {
          return {
            t: 0,
            scene: new Scene3D(cube),
            camera: 'projective',
            // camera: 'parallel',
            active: true,
          }
        },
        computed: {
          screen() {
            if (this.camera == 'projective') {
              return new Screen(600, 300, new ProjectiveCamera(1))
            }
            return new Screen(600, 300, new IsometricCamera(200))
          },
        },
        components: { threeDScene },
        mounted() {
          setInterval(() => {
            if (this.active) {
              this.t++
            }
          }, 1000 / 30)
        },
      }).mount('#cube-wireframe')

      createApp({
        data() {
          return {
            t: 0, //29
            scene: new Scene3D(cube),
            camera: 'projective',
            // camera: 'parallel',
            active: true,
          }
        },
        computed: {
          screen() {
            if (this.camera == 'projective') {
              return new Screen(600, 300, new ProjectiveCamera(1))
            }
            return new Screen(600, 300, new IsometricCamera(200))
          },
        },
        components: { threeDScene },
        mounted() {
          setInterval(() => {
            if (this.active) {
              this.t++
            }
          }, 1000 / 30)
        },
      }).mount('#cube-faces')

      createApp({
        data() {
          return {
            t: 25, //29
            scene: new Scene3D(cube, farRectangle),
            camera: 'projective',
            // camera: 'parallel',
            active: true,
          }
        },
        computed: {
          screen() {
            if (this.camera == 'projective') {
              return new Screen(600, 300, new ProjectiveCamera(1))
            }
            return new Screen(600, 300, new IsometricCamera(200))
          },
        },
        components: { threeDScene },
        mounted() {
          setInterval(() => {
            if (this.active) {
              this.t++
            }
          }, 1000 / 30)
        },
      }).mount('#cube-rectangle-transparent')

      createApp({
        data() {
          return {
            t: 25,
            scene: new Scene3D(cube, farRectangle),
            // scene: new Scene3D(faceA, faceB),
            camera: 'projective',
            // camera: 'parallel',
            active: true,
          }
        },
        computed: {
          screen() {
            if (this.camera == 'projective') {
              return new Screen(600, 300, new ProjectiveCamera(1))
            }
            return new Screen(600, 300, new IsometricCamera(200))
          },
        },
        components: { threeDScene },
        mounted() {
          setInterval(() => {
            if (this.active) {
              this.t++
            }
          }, 1000 / 30)
        },
      }).mount('#cube-rectangle-occlusion')
    </script>
  </body>
</html>
