<!DOCTYPE html><html lang="en">

<head>
	<title>Triangular Grid Math</title>
	<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

	<style>
		body {
			--diagram-width: 60rem;
			--diagram-width-small: 20rem;

			/* font choices inspired by www.redblobgames.com */
			--sans-serif: "Avenir Next", Candara, Ubuntu, "Fira Sans", system-ui, "Segoe UI", sans-serif;
			--serif: "Iowan Old Style", Cambria, Georgia, serif;

			font-family: var(--sans-serif);
			font-size: 1.1em;
			margin: 0;
			
		}

		.body {
			margin-top: 5em;
			margin-left: 10em;
			margin-right: 20em;
		}

		header {
			display: block;
			text-align: center;
			background-color: hsl(0, 0%, 80%);
			height: 6em;
			font-size: 2.5em;
			padding-top: 0.5em;
		}

		h2 {
			font-size: 2em;
		}

		figure {
			box-sizing: border-box;
		}

		p {
			font-family: var(--serif);
			padding-left: 1em;
		}

		text {
			font-size: 1.1em;
			pointer-events: none;
			fill: black;
			font-family: var(--sans-serif);

			.x-coord {
				fill:hsl(0, 80%, 40%);
			}

			.y-coord {
				fill:hsl(240, 80%, 40%);
			}

			.r-coord {
				fill:hsl(280, 80%, 40%);
			}

			.z-coord {
				fill:hsl(120, 80%, 30%);
			}

			.b-coord {
				fill:hsl(40, 80%, 30%);
			}
		}

		.sameX text .x-coord,
		.sameY text .y-coord,
		.sameZ text .z-coord,
		.sameB text .b-coord {
			font-weight: 600;
		}

		.coord-labels {
			.numeric  {
				font-weight: 600;
			}
			.coord:not(.visible) {
				display: none;
			}
		}

		.highlight text {
			.x-coord, .y-coord, .r-coord, .b-coord {
				font-weight: 600;
			}
		}

		figure {
			border: 1px solid black;
		}

		svg {
			polygon {
				stroke:hsl(0,0%,70%);
				stroke-width:1;
			}

			.sameX polygon {
				fill: hsl(0, 50%, 70%);
			}

			.sameY polygon {
				fill: hsl(240, 50%, 70%);
			}

			.sameZ polygon {
				fill: hsl(120, 50%, 70%);
			}

			.sameB polygon {
				fill: hsl(280, 50%, 70%);
			}

			.uptriangle {
				fill:hsl(147, 0%, 80%);
			}

			.downtriangle {
				fill:hsl(147, 0%, 85%);
			}

			.highlight polygon {
				fill: hsl(40, 100%, 80%);
			}
		}

		.coordinate-buttons button {
			padding: 15px 30px;
			border:none;
			margin: 0 10px;
			text-align: center;
			font-size: 1.2em;
			background-color: hsl(0, 0, 70%);

			&.active {
				background-color: yellow;
			}
		}
	</style>
</head>

<body>
	
	<header><h1>Triangular Grid Math</h1></header>
	<div class="body">
		<section>
			<h2> (Jan 2026) WORK IN PROGRESS! </h2>
			<p>This little applet is inspired by <a href="https://www.redblobgames.com/grids/hexagons/#coordinates">this Amit/RedBlobGames blog post</a> on hexagonal grids. It also follows up on an <a href="https://simblob.blogspot.com/2007/06/distances-on-triangular-grid.html">earlier blogpost of theirs</a> about Triangle Grids, which sadly doesn't include any interactivity.</p>
			<p>I wanted to better familiarize myself with Vue and Javascript rendering, to extend my graphics work for a <a href="https://github.com/libeks/go-plotter-svg">Pen Plotter</a> and <a href="https://github.com/libeks/go-scene-renderer">3D CPU Renderer</a>.</p>
		</section>
		<section>
			<h2>Purpose</h2>
			<div class="float-container">
			<p>While working on <a href="https://en.wikipedia.org/wiki/Truchet_tile">Truchet tiles</a> and <a href="https://en.wikipedia.org/wiki/Marching_squares">Marching Squares</a> implementations, I found myself quite comfortable with a square grid. Take any rectangle, and subdivide it into squares (rectangles with all sides the same), and use their Cartesian (x,y) coordinates to refer to each individual square. Since I was working on plotting the results, and the pen starts at the upper left corner of the page, I found that this was a convenient origin point, with x-coordinate increasing left-to-right, and the y-coordinate increasing downwards.</p>
			<p>I then wanted to extend these approaches to other regular grids. Surprisingly, what coordinate system to use is not a trivial decision. As mentioned above, the choices for hexagons are many, one should choose the coordinate system that works best.</p>
			<p>What about triangles though? The plane can be divided up into equilateral triangles trivially, but how do we index them? Specifically, I am looking for a unique integer-based coordinate for each triangle, and an easy mapping between the coordinate and the corresponding triangle. Ideally, the coordinate system should be translation-invariant (the coordinates should change between adjacent triangles under the same pattern, no matter where in the grid the triangle exists), and it should lead to easy human interpretability.</p>
			<figure id="square-grid" style="width:var(--diagram-width-small)">
				<svg viewBox="0 0 1000 1000">
					<g class="coord-labels">
						<g class="x-coord coord" :style="toTransform(positioner.mapXCoord(selected))" :class="{visible: coordinates=='xyz' || coordinates=='xyr'}">
							<text>x = <tspan class="x-coord numeric">{{selected ? selected.x : 0}}</tspan></text>
						</g>
						<g class="y-coord coord" :style="toTransform(positioner.mapYCoord(selected))" :class="{visible: true}">
							<text>y = <tspan class="y-coord numeric">{{selected ? selected.y : 0}}</tspan></text>
						</g>
					</g>
					<g class="grid">
						<g v-for="sq in grid" :style="toTransform(positioner.mapTriangle(tri))" :class="className(sq, selected)" :data-tri="sq.string()" @mousemove="mouse" @click="click">
							<polygon @click="click"  points="0,0 0,100 100,100 100,0" />
							<text x="0" y="50" text-anchor="middle">
								<xy :sq="sq" />
							</text>
						</g>
					</g>
				</svg>
			</figure>
		</section>

		<section>
			<figure id="triangle-grid-complete" style="width:var(--diagram-width)">
				<svg viewBox="0 0 1200 800" border-box>
					<g class="coord-labels">
						<g class="x-coord coord" :style="toTransform(positioner.mapXCoord(selected))" :class="{visible: coordinates=='xyz' || coordinates=='xyr'}">
							<text>x = <tspan class="x-coord numeric">{{selected ? selected.x : 0}}</tspan></text>
						</g>
						<g class="y-coord coord" :style="toTransform(positioner.mapYCoord(selected))" :class="{visible: true}">
							<text>y = <tspan class="y-coord numeric">{{selected ? selected.y : 0}}</tspan></text>
						</g>
						<g class="z-coord coord" :style="toTransform(positioner.mapZCoord(selected))" :class="{visible: coordinates=='xyz'}">
							<text>z = <tspan class="z-coord numeric">{{selected ? selected.z : 0}}</tspan></text>
						</g>
						<g class="b-coord coord" :style="toTransform(positioner.mapBCoord(selected))" :class="{visible: coordinates=='yb'}">
							<text>b = <tspan class="b-coord numeric">{{selected ? selected.b : 0}}</tspan></text>
						</g>
						
					</g>
					<g class="grid">
						<g v-for="tri in grid.upTriangles()" :style="toTransform(positioner.mapTriangle(tri))" :class="className(tri, selected)" :data-tri="tri.string()" @mousemove="mouse" @click="click">
							<polygon @click="click"  points="0,0 -50,86.6 50,86.6" />
							<text x="0" y="75" text-anchor="middle">
								<component :is="coordinates" :tri="tri"></component>
							</text>
						</g>
						<g v-for="tri in grid.downTriangles()" :style="toTransform(positioner.mapTriangle(tri))" :class="className(tri, selected)" :data-tri="tri.string()" @mousemove="mouse" @click="click">
							<polygon points="0,86.6 -50,0 50,0"/>
							<text x="0" y="25" text-anchor="middle">
								<component :is="coordinates" :tri="tri"></component>
							</text>
						</g>
					</g>
				</svg>
				<div class="coordinate-buttons">
					<button @click='coordinates = "xyr"' :class="{ active: coordinates=='xyr'}">XYR</button>
					<button @click='coordinates = "xyz"' :class="{ active: coordinates=='xyz'}">XYZ</button>
					<button @click='coordinates = "yb"' :class="{ active: coordinates=='yb'}">YB</button>
				</div>
			</figure>
		</section>
	</div>
	<footer>
		© 2026 Jānis Lībeks
	</footer>


	<script>
		const { createApp, ref, defineComponent } = Vue

		class TriangleGrid {
			constructor({nX, nY, filter}) {
				this.triangles = [];
				for (let x = 0; x <= nX; x++) {
					for (let y = 0; y <= nY; y++) {
						for (const R of [0, 1]) {
							if (filter && filter(x,y,R)) { // Remove triangles that should be filtered out, to get the right output shape
								continue
							}
							this.triangles.push(new Triangle(x,y,R));
						}
					}
				}
			}

			widthByY(y) {
				let n = 0;
				for (const tri of this.triangles) {
					if (tri.y == y) {
						n ++
					}
				}
				return n;
			}

			upTriangles() {
				return this.triangles.filter((tri) => tri.R==0)
			}

			downTriangles() {
				return this.triangles.filter((tri) => tri.R==1)
			}
		}

		class Triangle {
			constructor(x,y,R) {
				// raw coordinates, these are used to identify a triangle
				this.x = x;
				this.y = y;
				this.R = R;
				
				// derived coordinates

				// x-y-z coordinates
				this.z = x-y + R; // uses the same x, y coords as above
				// y-b coordinates
				this.b = x + this.z; // corresponds to the "column" of the triangle
			}

			string() {
				return this.x + "," + this.y + "," + this.R
			}
		}

		class TrianglePositioner {
			constructor(padding, grid, size) {
				this.padding = padding
				this.grid = grid
				this.size = size
			}

			mapTriangle(tri) {
				return {
					x: this.padding.x + -this.size/2*(tri.y%2) + (tri.x - Math.floor(tri.y/2)) * this.size + (this.size/2)*tri.R,
					y: this.padding.y + tri.y * 86.6,
				}
			}

			mapYCoord(coord) {
				if (!coord) {
					return {x:0, y:0};
				}
				return {
					x: this.padding.x + this.size * this.grid.widthByY(coord.y)/2 + 40, 
					y: coord.y*86.6 + 50 + this.padding.y,
				};
			}

			mapXCoord(coord) {
				// TODO: lower label when possible
				if (!coord) {
					return {x:0, y:0};
				}
				return {
					x: this.padding.x + 50 + coord.x*this.size, 
					y: this.padding.y - 25,
					rotate: -60,
				};
			}

			mapZCoord(coord) {
				// TODO: lower label when possible
				if (!coord) {
					return {x:0, y:0};
				}
				return {
					x: this.padding.x + coord.z*this.size  - this.size, 
					y: this.padding.y - 50,
					rotate: 60,
				};
			}

			mapBCoord(coord) {
				if (!coord) {
					return {x:0, y:0};
				}
				return {
					x: this.padding.x + coord.b*this.size/2, 
					y: this.padding.y - 25,
					rotate: -90,
				};
			}
		}
		
		function toTransform(offsetVect) {
			if (offsetVect.rotate) {
				return {
					transform: "translate("+offsetVect.x+"px,"+offsetVect.y+"px) rotate("+offsetVect.rotate+"deg)",
				}
			}
			return {
				transform: "translate("+offsetVect.x+"px,"+offsetVect.y+"px)",
			}
		}

		function className(tri, selected) {
			if (this.selected === null) {
				return {
					uptriangle: tri.R==0,
					downtriangle: tri.R==1,
				}
			}
			const highlight = tri.string() == this.selected.string()
			return {
				highlight,
				...(this.coordinates == "xyz" || this.coordinates == "xyr") && {sameX: tri.x==this.selected.x && !highlight},
				sameY: tri.y==this.selected.y && !highlight, // y coordinate is used in call coordinate systems
				...(this.coordinates == "xyr") && {sameR: tri.R==this.selected.R && !highlight},
				...(this.coordinates == "xyz") && {sameZ: tri.z==this.selected.z && !highlight},
				...(this.coordinates == "yb") && {sameB: tri.b==this.selected.b && !highlight},
				uptriangle: tri.R==0,
				downtriangle: tri.R==1,
			}
		}

		function setActiveTriangle(triString) {
			for (const tri of this.grid.triangles) {
				if (tri.string() == triString) {
					this.selected = tri;
					return
				}
			}
		}

		function mouse(event) {
			this.setActiveTriangle(event.target.parentElement.dataset.tri);
		}

		function click(event) {
			this.setActiveTriangle(event.target.parentElement.dataset.tri);
		}

		// Components to display triangle coordinates, in the three coordinate systems

		const xyz = {
			template: `<tspan class="x-y-z-coord"><tspan class="x-coord">{{tri.x}}</tspan>, <tspan class="y-coord">{{tri.y}}</tspan>, <tspan class="z-coord">{{tri.z}}</tspan></tspan>`,
		  props: ['tri'],
		};
		const xyr = {
			template: `<tspan class="x-y-r-coord"><tspan class="x-coord">{{tri.x}}</tspan>, <tspan class="y-coord">{{tri.y}}</tspan>, <tspan class="r-coord">{{tri.R}}</tspan></tspan>`,
		  props: ['tri'],
		};
		const yb = {
			template: `<tspan class="y-b-coord"><tspan class="y-coord">{{tri.y}}</tspan>, <tspan class="b-coord">{{tri.b}}</tspan></tspan>`,
		  props: ['tri'],
		};

		let triangleGrid = new TriangleGrid({
			nX: 12, 
			nY: 7, 
			filter: (x,y,R) => (x + R/2 < y/2) || (x + R/2 - y/2 > 9),
			// filter: (x,y,R) => (x + R/2 < y/2), 
		});

		const fullTriangleApp = createApp({
			data() {
				return {
					selected: null,
					grid:triangleGrid,
					positioner: new TrianglePositioner(
						{x: 100, y: 100},
						triangleGrid,
						100,
					),
					coordinates: "xyr",
				}
			},
			methods: {
				mouse,
				click,
				className,
				setActiveTriangle,
				toTransform,
			},
			components: {
				xyz,
				xyr,
				yb,
			}
		}).mount('#triangle-grid-complete');

		let squareGrid = new TriangleGrid({
			nX: 12, 
			nY: 7, 
			filter: (x,y,R) => (x + R/2 < y/2) || (x + R/2 - y/2 > 9),
			// filter: (x,y,R) => (x + R/2 < y/2), 
		});

		const squareApp = createApp({
			data() {
				return {
					selected: null,
					grid: squareGrid,// grid, 
					positioner: new TrianglePositioner(
						{x: 100, y: 100},
						squareGrid,
						100,
					),
					coordinates: "xyr",
				}
			},
			methods: {
				mouse,
				click,
				className,
				setActiveTriangle,
				toTransform,
			},
			components: {
				xyz,
				xyr,
				yb,
			}
		}).mount('#square-grid');
	</script>
</body>

</html>