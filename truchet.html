<!doctype html>
<html lang="en">
  <head>
    <title>Truchet Tiles</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link href="style.css" rel="stylesheet" />
    <link href="triangles.css" rel="stylesheet" />
    <link rel="icon" href="favicon.svg" type="image/svg+xml" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Libertinus+Math&display=swap"
      rel="stylesheet"
    />
  </head>

  <body>
    <header>
      <h1>Truchet Tiles</h1>
      <div class="subhead"><a href="index.html">Home</a></div>
    </header>
    <main>
      <section>
        <p>
          This is a follow-up on the post about <a href="triangles.html">Triangular Grids</a>, to
          see how easily we could adapt a regular grid for Truchet tiles.
        </p>
      </section>
      <section>
        <h2 id="rectangular-grid">
          <a class="anchor" href="#rectangular-grid"></a>
          <span>Rectangular Grid</span>
        </h2>
        <section class="subsection">
          <h3 id="rectangular-simple-tile">
            <a class="anchor" href="#rectangular-simple-tile"></a>
            <span>Simple tile</span>
          </h3>
          <div class="flex-container">
            <p>
              We start, as always, with the simple Cartesian grid, and the simplest set of two
              Truchet tiles.
            </p>
            <figure class="float-right small">
              <svg viewBox="0 0 400 200">
                <g class="grid square">
                  <g class="square" style="transform: translate(75px, 50px)">
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(275px, 50px)">
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>Simplest two Truchet tiles with quarter-circle sections</figcaption>
            </figure>
          </div>
          <p>For the grid, we randomly choose from either of the two tiles. Lovely, isn't it?</p>
          <figure id="square-grid-two-tile" class="full-width">
            <svg viewBox="0 0 3000 1500">
              <g class="grid squares">
                <g
                  v-for="sq in grid.grid.getSquares()"
                  :style="toTransform(grid.mapSquare(sq))"
                  :class="sqClassName(sq, selected)"
                  :data-sq="sq.string()"
                >
                  <g v-if="sq.data==0" class="tile">
                    <polygon points="0,0 0,100 100,100 100,0" />
                    <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                    <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                  </g>
                  <g v-if="sq.data==1" class="tile rot90deg">
                    <polygon points="0,0 0,100 100,100 100,0" />
                    <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                    <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                  </g>
                  <!-- <text>{{sq.data}}</text> -->
                </g>
              </g>
            </svg>
          </figure>
        </section>
        <section class="subsection">
          <h3 id="more-complex-tiles">
            <a class="anchor" href="#more-complex-tiles"></a>
            <span>More complex tiles</span>
          </h3>
          <div class="flex-container">
            <p>
              We of course are not limited to these two tiles. In fact, we can come up with as many
              tiles as we like, as long as they contain strokes that "exit" the tile at the four
              cardinal directions.
            </p>
            <figure id="square-grid" class="float-right small">
              <svg viewBox="0 0 430 220">
                <g class="grid square">
                  <g class="square" style="transform: translate(0px, 10px)">
                    <!-- Two quarter circles -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(110px, 10px)">
                    <!-- Two quarter circles, turned 90 degrees -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(220px, 10px)">
                    <!-- Cross -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(330px, 10px)">
                    <!-- Cross under -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 30 50 M 70 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(0px, 120px)">
                    <!-- Cross over -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 30 50 M 70 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(110px, 120px)">
                    <!-- Wiggle -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path
                        class="stroke"
                        d="M 0 50 A 16.6 16.6 1 0 0 16.6 33.3 A 16.6 16.6 1 0 1 33.3 16.6 A 16.6 16.6 1 0 0 50 0"
                      />
                      <path
                        class="stroke"
                        d="M 100 50 A 16.6 16.6 1 0 0 83.3 66.6 A 16.6 16.6 1 0 1 66.6 83.3 A 16.6 16.6 1 0 0 50 100"
                      />
                    </g>
                  </g>
                  <g class="square" style="transform: translate(220px, 120px)">
                    <!-- Wiggle rotated 90deg -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path
                        class="stroke"
                        d="M 0 50 A 16.6 16.6 1 0 0 16.6 33.3 A 16.6 16.6 1 0 1 33.3 16.6 A 16.6 16.6 1 0 0 50 0"
                      />
                      <path
                        class="stroke"
                        d="M 100 50 A 16.6 16.6 1 0 0 83.3 66.6 A 16.6 16.6 1 0 1 66.6 83.3 A 16.6 16.6 1 0 0 50 100"
                      />
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>Some other tiles added for fun</figcaption>
            </figure>
          </div>
          <figure id="square-grid-five-tile" class="full-width">
            <svg viewBox="0 0 3000 1500">
              <g class="grid squares">
                <g
                  v-for="sq in grid.grid.getSquares()"
                  :style="toTransform(grid.mapSquare(sq))"
                  :class="sqClassName(sq, selected)"
                  :data-sq="sq.string()"
                >
                  <g v-if="sq.data==0" class="square">
                    <!-- Two quarter circles -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                  <g v-if="sq.data==1" class="square">
                    <!-- Two quarter circles, turned 90 degrees -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 A 50 50 1 0 0 50 0" />
                      <path class="stroke" d="M 100 50 A 50 50 1 0 0 50 100" />
                    </g>
                  </g>
                  <g v-if="sq.data==2" class="square">
                    <!-- Cross -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g v-if="sq.data==3" class="square">
                    <!-- Cross under -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 30 50 M 70 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g v-if="sq.data==4" class="square">
                    <!-- Cross over -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path class="stroke" d="M 0 50 L 30 50 M 70 50 L 100 50" />
                      <path class="stroke" d="M 50 0 L 50 100" />
                    </g>
                  </g>
                  <g v-if="sq.data==5" class="square">
                    <!-- Wiggle -->
                    <g class="tile">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path
                        class="stroke"
                        d="M 0 50 A 16.6 16.6 1 0 0 16.6 33.3 A 16.6 16.6 1 0 1 33.3 16.6 A 16.6 16.6 1 0 0 50 0"
                      />
                      <path
                        class="stroke"
                        d="M 100 50 A 16.6 16.6 1 0 0 83.3 66.6 A 16.6 16.6 1 0 1 66.6 83.3 A 16.6 16.6 1 0 0 50 100"
                      />
                    </g>
                  </g>
                  <g v-if="sq.data==6" class="square">
                    <!-- Wiggle rotated 90deg -->
                    <g class="tile rot90deg">
                      <polygon points="0,0 0,100 100,100 100,0" />
                      <path
                        class="stroke"
                        d="M 0 50 A 16.6 16.6 1 0 0 16.6 33.3 A 16.6 16.6 1 0 1 33.3 16.6 A 16.6 16.6 1 0 0 50 0"
                      />
                      <path
                        class="stroke"
                        d="M 100 50 A 16.6 16.6 1 0 0 83.3 66.6 A 16.6 16.6 1 0 1 66.6 83.3 A 16.6 16.6 1 0 0 50 100"
                      />
                    </g>
                  </g>
                </g>
              </g>
            </svg>
          </figure>
        </section>
      </section>
      <section>
        <h2 id="triangular-grid">
          <a class="anchor" href="#triangular-grid"></a>
          <span>Naïve Triangular Grid</span>
        </h2>
        <section class="subsection">
          <h3 id="triangle-rotation">
            <a class="anchor" href="#triangle-rotation"></a>
            <span>Triangle rotation</span>
          </h3>
          <div class="flex-container">
            <p>
              As an aside, let me tell you about rotating triangles. When working with triangular
              grids, you'll find yourself wanting to rotate a triangle both at 180° (flip it upside
              down), as well as 120° and 240° (turn it a third around). What was somewhat surprising
              to me is that the centers of rotation are not the same for the two actions! For 180°,
              we use the point that is halfway down the height of the triangle. For 120° rotations,
              use the midpoint of the triangle, which would be
              <math
                ><mfrac><mn>1</mn> <mn>3</mn></mfrac></math
              >
              of the height of the triangle.
            </p>
            <figure class="float-right small">
              <svg viewBox="0 0 300 300">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(150px, 50px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />

                      <circle class="stroke medium red" cx="0" cy="28.87" r="0.5" />
                      <text x="10" y="29" class="medium">1/3 rotation center</text>
                      <circle class="stroke medium blue" cx="0" cy="43.3" r="0.5" />
                      <text x="10" y="45" class="medium">1/2 rotation center</text>
                    </g>
                  </g>
                  <g class="triangle" style="transform: translate(75px, 175px)">
                    <g class="tile rotation-180-animation">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke medium rounded" d="M -20 10 l 0 20" />
                      <path class="stroke medium rounded" d="M -20 10 l 8 8" />
                      <path class="stroke medium rounded" d="M -20 10 l -8 8" />

                      <path class="stroke medium rounded" d="M 20 10 l 0 20" />
                      <path class="stroke medium rounded" d="M 20 10 l 8 8" />
                      <path class="stroke medium rounded" d="M 20 10 l -8 8" />

                      <path class="stroke medium rounded" d="M 0 50 l 0 20" />
                      <path class="stroke medium rounded" d="M 0 50 l 8 8" />
                      <path class="stroke medium rounded" d="M 0 50 l -8 8" />

                      <circle class="stroke medium blue" cx="0" cy="43.3" r="0.5" />
                      <circle class="stroke medium red" cx="0" cy="28.87" r="0.5" />
                    </g>
                  </g>
                  <g class="triangle" style="transform: translate(200px, 175px)">
                    <g class="tile rotation-120-animation">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke medium rounded" d="M -20 10 l 0 20" />
                      <path class="stroke medium rounded" d="M -20 10 l 8 8" />
                      <path class="stroke medium rounded" d="M -20 10 l -8 8" />

                      <path class="stroke medium rounded" d="M 20 10 l 0 20" />
                      <path class="stroke medium rounded" d="M 20 10 l 8 8" />
                      <path class="stroke medium rounded" d="M 20 10 l -8 8" />

                      <path class="stroke medium rounded" d="M 0 50 l 0 20" />
                      <path class="stroke medium rounded" d="M 0 50 l 8 8" />
                      <path class="stroke medium rounded" d="M 0 50 l -8 8" />

                      <circle class="stroke medium blue" cx="0" cy="43.3" r="0.5" />
                      <circle class="stroke medium red" cx="0" cy="28.87" r="0.5" />
                    </g>
                  </g>
                  <g>
                    <path class="stroke thin" d="M 0 175 l 400 0" />
                    <path class="stroke thin" d="M 0 261.6 l 400 0" />
                  </g>
                </g>
              </svg>
              <figcaption>
                To flip a triangle vertically, use the blue center of rotation. To flip it by a
                third, use the red one.
              </figcaption>
            </figure>
          </div>
        </section>
        <section class="subsection">
          <h3 id="simple-truchet-tile">
            <a class="anchor" href="#simple-truchet-tile"></a>
            <span>Simple Truchet Tile</span>
          </h3>
          <div class="flex-container">
            <p>
              Surely, we could extend this idea to equilateral triangles, since they, too, can tile
              the plane beautifully! The first problem is that a triangle has three sides, so we
              only have three potential edge connection points. If we only choose tiles that use one
              line to connect two of the sides, while leaving the third empty, we get a disjointed
              grid that isn't much fun.
            </p>

            <figure class="float-right small">
              <svg viewBox="0 0 400 200">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(50px, 50px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                  <g class="triangle" style="transform: translate(175px, 50px)">
                    <g class="tile rot120deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                  <g class="triangle" style="transform: translate(300px, 50px)">
                    <g class="tile rot240deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>Naïve triangular tile with one curve, with rotational copies</figcaption>
            </figure>
          </div>
          <figure id="triangle-grid-three-tile" class="full-width">
            <svg viewBox="0 0 1500 540">
              <g class="grid triangles">
                <g
                  v-for="tr in grid.grid.triangles"
                  :style="toTransform(grid.mapTriangle(tr))"
                  :class="triClassName(tr, selected)"
                  :data-tri="tr.string()"
                >
                  <g v-if="tr.data==0" class="flippable">
                    <g @click="click" class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                  <g v-if="tr.data==1" class="flippable">
                    <g @click="click" class="tile rot120deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                  <g v-if="tr.data==2" class="flippable">
                    <g @click="click" class="tile rot240deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M 0 0 A 50 50 1 0 1 -25 43.3" />
                    </g>
                  </g>
                </g>
              </g>
            </svg>
          </figure>
        </section>
      </section>
      <section>
        <h2 id="two-notcher-per-edge">
          <a class="anchor" href="#two-notcher-per-edge"></a>
          <span>Triangular grid with two notches per edge</span>
        </h2>
        <section class="subsection">
          <h3 id="circular-curves">
            <a class="anchor" href="#circular-curves"></a>
            <span>Circular curves</span>
          </h3>
          <div class="flex-container">
            <p>
              What we really want is to ensure that lines continue throughout the plot, like we see
              in the Rectangular grids above. For this, we can outline two points (or "notches") on
              each side, making six potential connection points. We then merely need to come up with
              all the tiles that have these properties. For the first approach, I will connect pairs
              of edge points such that they do not cross. For three pairs of points, the number of
              such tiles actually turns out to be equal to the
              <a href="https://en.wikipedia.org/wiki/Catalan_number">Catalan number</a>
              <math
                ><mrow
                  ><msub><mi>C</mi><mn>3</mn></msub
                  ><mo>=</mo><mn>5</mn></mrow
                > </math
              >. One way to think of this as a Catalan expression is to imagine a sequence of
              balance parentheses. If we number the edges clockwise from the top left, starting with
              1, then one way to represent the first tile on the right is as '12,34,56', or as
              '()()()'. For now I'll stick to using just circular segments, which lead to a slight
              overlap for the last three tiles. We'll have to use Bézier curves to get rid of this
              overlap.
            </p>
            <figure class="float-right small">
              <svg viewBox="0 0 400 300">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(113px, 20px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 16.6 16.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M -33.3 28.87 A 16.6 16.6 1 0 1 -16.6 57.78" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                    <text x="0" y="105" class="annotation center">12,34,56</text>
                    <text x="0" y="120" class="annotation center">()()()</text>
                  </g>
                  <g class="triangle" style="transform: translate(238px, 20px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 33.3 33.3 1 0 1 16.6 57.78" />
                      <path class="stroke" d="M 33.3 28.67 A 33.3 33.3 1 0 1 16.6 0" />
                    </g>
                    <text x="0" y="105" class="annotation center">16,23,45</text>
                    <text x="0" y="120" class="annotation center">(()())</text>
                  </g>
                  <g class="triangle" style="transform: translate(50px, 160px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 66.6 66.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                    <text x="0" y="105" class="annotation center">16,25,34</text>
                    <text x="0" y="120" class="annotation center">((()))</text>
                  </g>
                  <g class="triangle" style="transform: translate(175px, 160px)">
                    <g class="tile rot120deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 66.6 66.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                    <text x="0" y="105" class="annotation center">14,23,56</text>
                    <text x="0" y="120" class="annotation center">(())()</text>
                  </g>
                  <g class="triangle" style="transform: translate(300px, 160px)">
                    <g class="tile rot240deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 66.6 66.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                    <text x="0" y="105" class="annotation center">12,36,45</text>
                    <text x="0" y="120" class="annotation center">()(())</text>
                  </g>
                </g>
              </svg>
              <figcaption>
                Simple triangular tiles with two connections per edge, using only individual circle
                segments
              </figcaption>
            </figure>
          </div>
          <figure id="triangle-grid-two-tile" class="full-width">
            <svg viewBox="0 0 1500 692.8">
              <g class="grid triangles">
                <g
                  v-for="tr in grid.grid.triangles"
                  :style="toTransform(grid.mapTriangle(tr))"
                  :class="triClassName(tr, selected)"
                  :data-tri="tr.string()"
                >
                  <g v-if="tr.data==0" class="flippable">
                    <g @click="click" class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 33.3 33.3 1 0 1 16.6 57.78" />
                      <path class="stroke" d="M 33.3 28.67 A 33.3 33.3 1 0 1 16.6 0" />
                    </g>
                  </g>
                  <g v-if="tr.data==1" class="flippable">
                    <g @click="click" class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 16.6 16.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M -33.3 28.87 A 16.6 16.6 1 0 1 -16.6 57.78" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                  </g>
                  <g v-if="tr.data==2" class="flippable">
                    <g @click="click" class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 33.3 33.3 1 0 1 16.6 57.78" />
                      <path class="stroke" d="M 33.3 28.67 A 33.3 33.3 1 0 1 16.6 0" />
                    </g>
                  </g>
                  <g v-if="tr.data==3" class="flippable">
                    <g @click="click" class="tile rot120deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 66.6 66.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                  </g>
                  <g v-if="tr.data==4" class="flippable">
                    <g @click="click" class="tile rot240deg">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke" d="M -16.6 0 A 33.3 33.3 1 0 1 -33.3 28.87" />
                      <path class="stroke" d="M -16.6 57.78 A 66.6 66.6 1 0 0 16.6 0" />
                      <path class="stroke" d="M 16.6 57.78 A 16.6 16.6 1 0 1 33.3 28.67" />
                    </g>
                  </g>
                </g>
              </g>
            </svg>
          </figure>
        </section>
        <section class="subsection">
          <h3 id="bezier-curves">
            <a class="anchor" href="#bezier-curves"></a>
            <span>Bézier curves</span>
          </h3>
          <p>
            Next, let's see how to make sure those lines don't overlap. To make sure the lines don't
            look disconnected or jagged, it is wise to ensure that they connect to the edge of the
            tile perpendicularly. Luckily, so long as we keep the first and last Bézier edge
            perpendicular to the tile edge, this should work!
          </p>
          <div class="flex-container">
            <p>
              For this, it might be helpful to talk about the measurements of the triangle. I've
              decided that it would be best to handle a triangle that has side length of 100 units.
              The height of the triangle is then
              <math>
                <mn>50</mn><mo>&#x2062;</mo><msqrt><mn>3</mn></msqrt> <mo>=</mo>
                <mn>86.6</mn> </math
              >. I divide each edge into three equal parts of length <math><mn>33.3</mn></math
              >. The midpoint of the triangle is of course
              <math>
                <mfrac><mn>1</mn> <mn>3</mn></mfrac>
              </math>
              of the way down the height. I extend the notches on the edges until they intersect,
              leading to three points on the interior, which will form the control points of the
              Bézier curves.
            </p>
            <figure id="triangle-two-notch-points" class="float-right small">
              <svg viewBox="0 0 150 120">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(75px, 25px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />

                      <!-- diagonals -->
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['origin'], points['c3']).d()"
                      />
                      <path class="stroke thin" d="M -25 43.4 L 50 0" />
                      <path class="stroke thin" d="M 25 43.4 L -50 0" />

                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n1'], points['n1star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n2'], points['n2star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n3'], points['n3star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n4'], points['n4star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n5'], points['n5star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n6'], points['n6star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n1star'], points['n2star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n2star'], points['n4star']).d()"
                      />
                      <path
                        class="stroke thin"
                        :d="new StraightStroke(points['n4star'], points['n1star']).d()"
                      />

                      <!-- lower vertex -->
                      <circle class="stroke medium" cx="0" cy="86.6" r="0.5" />
                      <text x="-8" y="93" class="small">(0,86.6)</text>
                      <!-- left vertex -->
                      <circle class="stroke medium" cx="-50" cy="0" r="0.5" />
                      <text x="-57" y="-3" class="small">(-50,0)</text>
                      <!-- right vertex -->
                      <circle class="stroke medium" cx="50" cy="0" r="0.5" />
                      <text x="42" y="-3" class="small">(50,0)</text>
                      <!-- origin -->
                      <circle class="stroke medium" cx="0" cy="0" r="0.5" />
                      <text x="-5" y="-3" class="small">(0,0)</text>
                      <!-- tripoint 1 -->
                      <circle class="stroke medium" v-bind="points['c1star'].cxcyProps()" r="0.5" />
                      <text v-bind="points['c1star'].d(-14, -4).xyProps()" class="small">
                        {{points['c1star'].display()}}
                      </text>
                      <!-- tripoint 2 -->
                      <circle class="stroke medium" v-bind="points['c2star'].cxcyProps()" r="0.5" />
                      <text v-bind="points['c2star'].d(-9, -4).xyProps()" class="small">
                        {{points['c2star'].display()}}
                      </text>
                      <!-- tripoint 3 -->
                      <circle class="stroke medium" v-bind="points['c3star'].cxcyProps()" r="0.5" />
                      <text v-bind="points['c3star'].d(-5, -4).xyProps()" class="small">
                        {{points['c3star'].display()}}
                      </text>
                      <!-- midpoint -->
                      <circle class="stroke medium" cx="0" cy="28.87" r="0.5" />
                      <text x="4" y="30" class="small">(0,28.9)</text>
                      <!-- notch 1 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n1'].d(0,-2), points['n1'].d(0,2)).d()"
                      />
                      <text v-bind="points['n1'].d(-9,-3).xyProps()" class="small">
                        {{points['n1'].display()}}
                      </text>
                      <!-- notch 2 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n2'].d(0,-2), points['n2'].d(0,2)).d()"
                      />
                      <text v-bind="points['n2'].d(-9,-3).xyProps()" class="small">
                        {{points['n2'].display()}}
                      </text>
                      <!-- notch 3 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n3'].d(1.6,1), points['n3'].d(-1.6,-1)).d()"
                      />
                      <text v-bind="points['n3'].d(4,2).xyProps()" class="small">
                        {{points['n3'].display()}}
                      </text>
                      <!-- notch 4 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n4'].d(1.6,1), points['n4'].d(-1.6,-1)).d()"
                      />
                      <text v-bind="points['n4'].d(4,2).xyProps()" class="small">
                        {{points['n4'].display()}}
                      </text>
                      <!-- notch 5 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n5'].d(-1.6,1), points['n5'].d(1.6,-1)).d()"
                      />
                      <text text-anchor="end" v-bind="points['n5'].d(-4,2).xyProps()" class="small">
                        {{points['n5'].display()}}
                      </text>
                      <!-- notch 6 -->
                      <path
                        class="stroke notch"
                        :d="new StraightStroke(points['n6'].d(-1.6,1), points['n6'].d(1.6,-1)).d()"
                      />
                      <text text-anchor="end" v-bind="points['n6'].d(-4,2).xyProps()" class="small">
                        {{points['n6'].display()}}
                      </text>
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>
                Measurements of an equilateral triangle with edge 100 and variable notch position.
                <div class="annotation">
                  <div class="row">
                    <div>Notch position:</div>
                    <input
                      class="slider"
                      type="range"
                      name="notch"
                      min="0.05"
                      max="0.95"
                      step="0.01"
                      v-model.number="notch"
                    />
                  </div>
                </div>
              </figcaption>
            </figure>
          </div>
          <div class="flex-container">
            <p>
              Finally, it is helpful to know that Bézier curves are contained within the convex
              polygon outlined by its control points, and the normal vector at each endpoint is
              parallel to the control edge touching it, so we get perpendicularity for free.
            </p>
            <figure class="float-right small">
              <svg viewBox="0 0 150 120">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(75px, 25px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke thin" d="M 0 0 L 0 86.6" />
                      <path class="stroke thin" d="M -25 43.4 L 50 0" />
                      <path class="stroke thin" d="M 25 43.4 L -50 0" />
                      <path class="stroke thin" d="M 16.6 19.24 L 0 48.14" />
                      <path class="stroke thin" d="M -16.6 19.24 L 0 48.14" />

                      <path class="stroke thin red" d="M -33.3 28.87 L -16.6 19.24" />
                      <path class="stroke thin red" d="M -16.6 0 L -16.6 19.24" />
                      <path class="stroke thin red" d="M 16.6 0 L 16.6 19.24" />
                      <path class="stroke thin red" d="M 33.3 28.87 L 16.6 19.24" />
                      <path class="stroke thin red" d="M -16.6 57.73 L 0 48.14" />
                      <path class="stroke thin red" d="M 16.6 57.73 L 0 48.14" />
                      <path class="stroke thin red" d="M -16.6 19.24 L 16.6 19.24" />

                      <path class="stroke medium" d="M -16.6 0 C -16.6 19.24, 16.6 19.24, 16.6 0" />
                      <path
                        class="stroke medium"
                        d="M -33.3 28.87 C -16.6 19.24, 16.6 19.24, 33.3 28.87"
                      />
                      <path class="stroke medium" d="M -16.6 57.73 Q 0 48.14, 16.6 57.73" />
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>
                Non-overlapping Bézier curves, along with the control contours.
              </figcaption>
            </figure>
          </div>
          <div class="flex-container">
            <p>
              So let's take a look at the five tiles using Bézier curves. They look much neater this
              time!
            </p>
            <figure id="tile-5-listing" class="float-right small">
              <svg viewBox="0 0 400 240">
                <g class="grid triangle">
                  <g
                    v-for="(tile, i) in tiles"
                    class="triangle"
                    :style="toTransform({x: 50+(125/2)*Math.floor(i/3)+125*(i%3), y: 20+100*Math.floor(i/3)})"
                  >
                    <two-tile-factory :notch="notch" :tile="tile" />
                  </g>
                </g>
              </svg>
              <figcaption>
                The same five triangular Truchet tiles, this time with Bézier curves. No overlaps!
                <div class="annotation">
                  <div class="row">
                    <div>Notch:</div>
                    <input
                      class="slider"
                      type="range"
                      name="notch"
                      min="0.05"
                      max="0.95"
                      step="0.01"
                      v-model.number="notch"
                    />
                  </div>
                </div>
              </figcaption>
            </figure>
          </div>
          <figure id="triangle-grid-two-bezier-tile" class="full-width">
            <svg viewBox="0 0 1500 692.8">
              <g class="grid triangles">
                <g
                  v-for="tr in grid.grid.triangles"
                  :style="toTransform(grid.mapTriangle(tr))"
                  :class="triClassName(tr, selected)"
                  :data-tri="tr.string()"
                >
                  <g class="flippable">
                    <two-tile-factory @click="click" :notch="notch" :tile="tiles[tr.data]" />
                  </g>
                </g>
              </g>
            </svg>
            <figcaption>
              <div class="annotation">
                <div class="row">
                  <div>Notch position:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch"
                  />
                </div>
              </div>
            </figcaption>
          </figure>
        </section>
        <section class="subsection">
          <h3 id="intersecting-connections">
            <a class="anchor" href="#intersecting-connections"></a>
            <span>Intersecting connections</span>
          </h3>
          <div class="flex-container">
            <p>
              We of course don't need to restrict ourselves to non-intersecting segments. We can
              start by naively letting them cross all over the place. The number of such unique
              tiles would be
              <math><mn>5</mn> <mo>·</mo> <mn>3</mn><mo>=</mo> <mn>15</mn></math> tiles. For your
              intution, you can think about how notch "1" can be connected to any of the 5 remaining
              notches. This leaves 4 notches not connected. Take the lowest number one, and you can
              choose between three other notches to connect it to. That leaves two notches which
              have to be connected, so there is no choice.
            </p>
            <figure class="float-right small">
              <svg viewBox="0 0 150 120">
                <g class="grid triangle">
                  <g class="triangle" style="transform: translate(75px, 25px)">
                    <g class="tile">
                      <polygon points="0,86.6 -50,0 50,0" />
                      <path class="stroke thin" d="M 0 0 L 0 86.6" />
                      <path class="stroke thin" d="M -25 43.4 L 50 0" />
                      <path class="stroke thin" d="M 25 43.4 L -50 0" />
                      <path class="stroke thin" d="M 16.6 19.24 L 0 48.14" />
                      <path class="stroke thin" d="M -16.6 19.24 L 0 48.14" />

                      <path class="stroke thin red" d="M -33.3 28.87 L -16.6 19.24" />
                      <path class="stroke thin red" d="M -16.6 0 L -16.6 19.24" />
                      <path class="stroke thin red" d="M 16.6 0 L 16.6 19.24" />
                      <path class="stroke thin red" d="M 33.3 28.87 L 16.6 19.24" />
                      <path class="stroke thin red" d="M -16.6 57.73 L 0 48.14" />
                      <path class="stroke thin red" d="M 16.6 57.73 L 0 48.14" />
                      <path class="stroke thin red" d="M -16.6 19.24 L 16.6 19.24" />

                      <path
                        class="stroke medium"
                        d="M -16.6 0 C -16.6 19.24, 16.6 19.24, 33.3 28.87"
                      />
                      <path
                        class="stroke medium"
                        d="M -33.3 28.87 C -16.6 19.24, 16.6 19.24, 16.6 0"
                      />
                    </g>
                  </g>
                </g>
              </svg>
              <figcaption>
                The new "odd" connections between 13 and 24, showing their Bézier contours
              </figcaption>
            </figure>
          </div>
          <div class="flex-container">
            <p>
              We merely have to iterate over all possible combinations. I list the tiles vertically,
              starting with ones beginning with "12", then "13", and so on.
            </p>
            <figure id="tile-15-listing" class="float-right small">
              <svg viewBox="0 0 500 400">
                <g class="grid triangle">
                  <g
                    v-for="(tile, i) in tiles"
                    class="triangle"
                    :style="toTransform({x:50+100*Math.floor(i/3),y:20+120*(i%3)})"
                  >
                    <two-tile-factory :tile="tile" />
                    <text x="0" y="105" class="annotation center">{{tile}}</text>
                  </g>
                </g>
              </svg>
              <figcaption>The fifteen tiles with overlapping curves.</figcaption>
            </figure>
          </div>
          <figure id="triangle-grid-fifteen-bezier-tile" class="full-width">
            <svg viewBox="0 0 1500 692.8">
              <!-- <truchet-triangle :grid="grid" :tileset="tileset" :selected="null" /> -->
              <g class="grid triangles">
                <g
                  v-for="tr in grid.grid.triangles"
                  :style="toTransform(grid.mapTriangle(tr))"
                  :class="triClassName(tr, selected)"
                  :data-tri="tr.string()"
                >
                  <g class="flippable">
                    <two-tile-factory @click="click" :tile="tiles[tr.data]" />
                  </g>
                </g>
              </g>
            </svg>
          </figure>
        </section>
      </section>
      <section>
        <h2 id="four-notch-triangles">
          <a class="anchor" href="#four-notch-triangles"></a>
          <span>Triangular grid with 4 notches</span>
        </h2>
        <div class="flex-container">
          <p>
            We can try to expand the triangular tiles by etching four instead of two notches on
            every side. This will result in twelve notches in total, which makes 6 pairs of notches
            to connect. Let's start by planning out how we'll render all of the possible
            connections.
          </p>
          <figure id="triangle-four-notch-points" class="float-right small">
            <svg viewBox="0 0 150 120">
              <g class="grid triangle">
                <g class="triangle" style="transform: translate(75px, 25px)">
                  <g class="tile">
                    <polygon points="0,86.6 -50,0 50,0" />

                    <path class="stroke thin" d="M 0 0 l 0 86.6" />
                    <!-- height -->
                    <path class="stroke thin" d="M -25 43.4 L 50 0" />
                    <!-- upper right diagonal -->
                    <path class="stroke thin" d="M 25 43.4 L -50 0" />
                    <!-- upper left diagonal -->

                    <!-- from N1 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n1'], points['t1']).d()"
                    />
                    <!-- from N2 to T2-->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n2'], points['t2']).d()"
                    />
                    <!-- from N3 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n3'], points['t3']).d()"
                    />
                    <!-- from N4 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n4'], points['t4']).d()"
                    />

                    <!-- from T1 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t4']).d()"
                    />
                    <!-- from T2 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t3']).d()"
                    />

                    <!-- from T4 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t4'], points['t6']).d()"
                    />
                    <!-- from T3 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t3'], points['t5']).d()"
                    />
                    <!-- from N5 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n5'], points['t4']).d()"
                    />
                    <!-- from N6 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n6'], points['t3']).d()"
                    />
                    <!-- from N7 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n7'], points['t5']).d()"
                    />
                    <!-- from T8 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n8'], points['t6']).d()"
                    />

                    <!-- from N9 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n9'], points['t6']).d()"
                    />
                    <!-- from N10 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nA'], points['t5']).d()"
                    />
                    <!-- from N11 to T2 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nB'], points['t2']).d()"
                    />
                    <!-- from N12 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nC'], points['t1']).d()"
                    />

                    <!-- from T1 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t6']).d()"
                    />
                    <!-- from T2 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t5']).d()"
                    />

                    <!-- lower vertex -->
                    <circle class="stroke medium" cx="0" cy="86.6" r="0.5" />
                    <text x="-8" y="93" class="small">(0,86.6)</text>
                    <!-- left vertex -->
                    <circle class="stroke medium" cx="-50" cy="0" r="0.5" />
                    <text x="-57" y="-3" class="small">(-50,0)</text>
                    <!-- right vertex -->
                    <circle class="stroke medium" cx="50" cy="0" r="0.5" />
                    <text x="42" y="-3" class="small">(50,0)</text>

                    <!-- origin -->
                    <circle class="stroke medium" cx="0" cy="0" r="0.5" />
                    <!-- tripoint T1 -->
                    <circle class="stroke medium" v-bind="points['t1'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t1'].d(0, -3).xyProps()" class="small">T1</text>
                    <!-- tripoint T2 -->
                    <circle class="stroke medium" v-bind="points['t2'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t2'].d(0, -3).xyProps()" class="small">T2</text>
                    <!-- tripoint T3 -->
                    <circle class="stroke medium" v-bind="points['t3'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t3'].d(0, -3).xyProps()" class="small">T3</text>
                    <!-- tripoint T4 -->
                    <circle class="stroke medium" v-bind="points['t4'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t4'].d(0, -3).xyProps()" class="small">T4</text>
                    <!-- tripoint T5 -->
                    <circle class="stroke medium" v-bind="points['t5'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t5'].d(2, -1).xyProps()" class="small">T5</text>
                    <!-- tripoint T6 -->
                    <circle class="stroke medium" v-bind="points['t6'].cxcyProps()" r="0.5" />
                    <text v-bind="points['t6'].d(2, -1).xyProps()" class="small">T6</text>

                    <!-- point N2+ -->
                    <circle class="stroke medium" v-bind="points['n2star'].cxcyProps()" r="0.5" />
                    <text v-bind="points['n2star'].d(0, -3).xyProps()" class="small">N2*</text>
                    <!-- point N3+ -->
                    <circle class="stroke medium" v-bind="points['n3star'].cxcyProps()" r="0.5" />
                    <text v-bind="points['n3star'].d(0, -3).xyProps()" class="small">N3*</text>
                    <!-- point N6+ -->
                    <circle class="stroke medium" v-bind="points['n6star'].cxcyProps()" r="0.5" />
                    <text v-bind="points['n6star'].d(3, 0).xyProps()" class="small">N6*</text>
                    <!-- point N7+ -->
                    <circle class="stroke medium" v-bind="points['n7star'].cxcyProps()" r="0.5" />
                    <text v-bind="points['n7star'].d(3, 0).xyProps()" class="small">N7*</text>
                    <!-- point N10+ -->
                    <circle class="stroke medium" v-bind="points['nAstar'].cxcyProps()" r="0.5" />
                    <text v-bind="points['nAstar'].d(-13, -3).xyProps()" class="small">N10*</text>
                    <!-- point N11+ -->
                    <circle class="stroke medium" v-bind="points['nBstar'].cxcyProps()" r="0.5" />
                    <text v-bind="points['nBstar'].d(-13, -3).xyProps()" class="small">N11*</text>
                    <!-- midpoint -->
                    <circle class="stroke medium" cx="0" cy="28.87" r="0.5" />
                    <text x="4" y="30" class="small">M</text>

                    <!-- notch N1 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n1'].d(0,-2), points['n1'].d(0,2)).d()"
                    />
                    <text v-bind="points['n1'].d(-5,-3).xyProps()" class="small">N1</text>
                    <!-- notch N2 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n2'].d(0,-2), points['n2'].d(0,2)).d()"
                    />
                    <text v-bind="points['n2'].d(-5,-3).xyProps()" class="small">N1</text>
                    <!-- notch N3 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n3'].d(0,-2), points['n3'].d(0,2)).d()"
                    />
                    <text v-bind="points['n3'].d(-5,-3).xyProps()" class="small">N3</text>
                    <!-- notch N4 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n4'].d(0,-2), points['n4'].d(0,2)).d()"
                    />
                    <text v-bind="points['n4'].d(-5,-3).xyProps()" class="small">N4</text>
                    <!-- notch N5 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n5'].d(1.6,1), points['n5'].d(-1.6,-1)).d()"
                    />
                    <text v-bind="points['n5'].d(4,1).xyProps()" class="small">N5</text>
                    <!-- notch N6 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n6'].d(1.6,1), points['n6'].d(-1.6,-1)).d()"
                    />
                    <text v-bind="points['n6'].d(4,1).xyProps()" class="small">N6</text>
                    <!-- notch N7 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n7'].d(1.6,1), points['n7'].d(-1.6,-1)).d()"
                    />
                    <text v-bind="points['n7'].d(4,1).xyProps()" class="small">N7</text>
                    <!-- notch N8 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n8'].d(1.6,1), points['n8'].d(-1.6,-1)).d()"
                    />
                    <text v-bind="points['n8'].d(4,1).xyProps()" class="small">N8</text>
                    <!-- notch N9 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['n9'].d(-1.6,1), points['n9'].d(1.6,-1)).d()"
                    />
                    <text v-bind="points['n9'].d(-12,1).xyProps()" class="small">N9</text>
                    <!-- notch N10 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['nA'].d(-1.6,1), points['nA'].d(1.6,-1)).d()"
                    />
                    <text v-bind="points['nA'].d(-12,1).xyProps()" class="small">N10</text>
                    <!-- notch N11 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['nB'].d(-1.6,1), points['nB'].d(1.6,-1)).d()"
                    />
                    <text v-bind="points['nB'].d(-12,1).xyProps()" class="small">N11</text>
                    <!-- notch N12 -->
                    <path
                      class="stroke notch"
                      :d="new StraightStroke(points['nC'].d(-1.6,1), points['nC'].d(1.6,-1)).d()"
                    />
                    <text v-bind="points['nC'].d(-12,1).xyProps()" class="small">N12</text>
                  </g>
                </g>
              </g>
            </svg>
            <figcaption>
              Four-notch measurements of an equilateral triangle with edge 100.
              <div class="annotation">
                <div class="row">
                  <div>Notch1:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch1"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch1"
                  />
                  <div>Notch2:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch2"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch2"
                  />
                </div>
              </div>
            </figcaption>
          </figure>
        </div>
        <div class="flex-container">
          <p>
            Figuring out how to connect all of the curves is not very trivial. I start off by
            connecting all pairs of notches that show axial symmetry along one of the heights of the
            triangle, giving six cases to consider. I'll admit, the logic here was not very pretty,
            sometimes I had to pick odd midpoints, but it worked out in the end.
          </p>
          <figure id="four-notch-examples-1" class="float-right small">
            <svg viewBox="0 0 150 120">
              <g class="grid triangle">
                <g class="triangle" style="transform: translate(75px, 25px)">
                  <g class="tile">
                    <polygon points="0,86.6 -50,0 50,0" />

                    <path class="stroke thin" d="M 0 0 l 0 86.6" />
                    <!-- height -->
                    <path class="stroke thin" d="M -25 43.4 L 50 0" />
                    <!-- upper right diagonal -->
                    <path class="stroke thin" d="M 25 43.4 L -50 0" />
                    <!-- upper left diagonal -->

                    <!-- from N1 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n1'], points['t1']).d()"
                    />
                    <!-- from N2 to T2-->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n2'], points['t2']).d()"
                    />
                    <!-- from N3 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n3'], points['t3']).d()"
                    />
                    <!-- from N4 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n4'], points['t4']).d()"
                    />

                    <!-- from T1 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t4']).d()"
                    />
                    <!-- from T2 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t3']).d()"
                    />

                    <!-- from T4 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t4'], points['t6']).d()"
                    />
                    <!-- from T3 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t3'], points['t5']).d()"
                    />
                    <!-- from N5 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n5'], points['t4']).d()"
                    />
                    <!-- from N6 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n6'], points['t3']).d()"
                    />
                    <!-- from N7 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n7'], points['t5']).d()"
                    />
                    <!-- from T8 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n8'], points['t6']).d()"
                    />

                    <!-- from N9 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n9'], points['t6']).d()"
                    />
                    <!-- from N10 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nA'], points['t5']).d()"
                    />
                    <!-- from N11 to T2 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nB'], points['t2']).d()"
                    />
                    <!-- from N12 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nC'], points['t1']).d()"
                    />

                    <!-- from T1 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t6']).d()"
                    />
                    <!-- from T2 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t5']).d()"
                    />

                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="14" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="23" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="5C" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="6B" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="7A" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="89" />
                  </g>
                </g>
              </g>
            </svg>
            <figcaption>
              Curves that are symmetrical along one height of the triangle.
              <div class="annotation">
                <div class="row">
                  <div>Notch1:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch1"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch1"
                  />
                  <div>Notch2:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch2"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch2"
                  />
                </div>
              </div>
            </figcaption>
          </figure>
        </div>
        <div class="flex-container">
          <p>
            Next, we have to consider the remaining curves on only one side of the height of the
            triangle, which only leaves two remaining curves. Again, I chose Quadratic and Cubic
            Bezier curves and picked from the control points listed above.
          </p>
          <figure id="four-notch-examples-2" class="float-right small">
            <svg viewBox="0 0 150 120">
              <g class="grid triangle">
                <g class="triangle" style="transform: translate(75px, 25px)">
                  <g class="tile">
                    <polygon points="0,86.6 -50,0 50,0" />

                    <path class="stroke thin" d="M 0 0 l 0 86.6" />
                    <!-- height -->
                    <path class="stroke thin" d="M -25 43.4 L 50 0" />
                    <!-- upper right diagonal -->
                    <path class="stroke thin" d="M 25 43.4 L -50 0" />
                    <!-- upper left diagonal -->

                    <!-- from N1 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n1'], points['t1']).d()"
                    />
                    <!-- from N2 to T2-->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n2'], points['t2']).d()"
                    />
                    <!-- from N3 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n3'], points['t3']).d()"
                    />
                    <!-- from N4 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n4'], points['t4']).d()"
                    />

                    <!-- from T1 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t4']).d()"
                    />
                    <!-- from T2 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t3']).d()"
                    />

                    <!-- from T4 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t4'], points['t6']).d()"
                    />
                    <!-- from T3 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t3'], points['t5']).d()"
                    />
                    <!-- from N5 to T4 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n5'], points['t4']).d()"
                    />
                    <!-- from N6 to T3 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n6'], points['t3']).d()"
                    />
                    <!-- from N7 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n7'], points['t5']).d()"
                    />
                    <!-- from T8 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n8'], points['t6']).d()"
                    />

                    <!-- from N9 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['n9'], points['t6']).d()"
                    />
                    <!-- from N10 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nA'], points['t5']).d()"
                    />
                    <!-- from N11 to T2 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nB'], points['t2']).d()"
                    />
                    <!-- from N12 to T1 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['nC'], points['t1']).d()"
                    />

                    <!-- from T1 to T6 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t1'], points['t6']).d()"
                    />
                    <!-- from T2 to T5 -->
                    <path
                      class="stroke thin"
                      :d="new StraightStroke(points['t2'], points['t5']).d()"
                    />

                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="1A" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="29" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="38" />
                    <four-curve-factory :notch1="notch1" :notch2="notch2" curve="47" />
                  </g>
                </g>
              </g>
            </svg>
            <figcaption>
              Curves that are symmetrical along one height of the triangle.
              <div class="annotation">
                <div class="row">
                  <div>Notch1:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch1"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch1"
                  />
                  <div>Notch2:</div>
                  <input
                    class="slider"
                    type="range"
                    name="notch2"
                    min="0.05"
                    max="0.95"
                    step="0.01"
                    v-model.number="notch2"
                  />
                </div>
              </div>
            </figcaption>
          </figure>
        </div>
        <p>
          I know that I will have
          <math
            ><msub><mi>C</mi><mn>6</mn></msub
            ><mo>=</mo><mn>132</mn></math
          >
          tiles. I generate all them using a simple algorithm, and you can see them all below. For
          brevity, I've ommitted the dash between pairs of letters. I also use the characters 'A' -
          'C' for values 10 through 12.
        </p>
        <figure id="triangle-grid-132-tiles" class="full-width">
          <svg viewBox="0 0 1200 1200">
            <g class="grid triangles">
              <g
                v-for="[i, tile] in catalan6.entries()"
                :style="toTransform({x:50+Math.floor(i/11)*100, y:(20+Math.sqrt(3)*50)*(i%11)})"
                class="triangle"
              >
                <g class="flippable">
                  <four-tile-factory :tile="tile" />
                  <text y="98" text-anchor="middle" class="large">{{tile}}</text>
                </g>
              </g>
            </g>
          </svg>
        </figure>
        <figure id="triangle-grid-132-truchet" class="full-width">
          <svg viewBox="0 0 1500 870">
            <g class="grid triangles">
              <g
                v-for="tr in grid.grid.triangles"
                :style="toTransform(grid.mapTriangle(tr))"
                :class="triClassName(tr, selected)"
                :data-tri="tr.string()"
              >
                <g class="flippable">
                  <four-tile-factory
                    @click="click"
                    :notch1="notch1"
                    :notch2="notch2"
                    :tile="catalan6[tr.data]"
                  />
                </g>
              </g>
            </g>
          </svg>
          <figurecaption>
            <div class="annotation">
              <div class="row">
                <div>Notch1:</div>
                <input
                  class="slider"
                  type="range"
                  name="notch1"
                  min="0.05"
                  max="0.95"
                  step="0.01"
                  v-model.number="notch1"
                />
                <div>Notch2:</div>
                <input
                  class="slider"
                  type="range"
                  name="notch2"
                  min="0.05"
                  max="0.95"
                  step="0.01"
                  v-model.number="notch2"
                />
              </div>
            </div>
          </figurecaption>
        </figure>
      </section>
      <section>
        <h2 id="further-ideas">
          <a class="anchor" href="#further-ideas"></a>
          <span>Further ideas to explore</span>
        </h2>
        <ul>
          <li>
            Let's say we want to render a continuous curve from a Truchet tiling. In the current
            implementation, each tile is rendered separately, the appearance of a continuous curve
            is purely coincidental. This might be come in handy when dealing with plotting a tiling
            with a pen plotter.
          </li>
          <li>What about hexagonal grids?</li>
          <li>
            What about other
            <a href="https://en.wikipedia.org/wiki/Euclidean_tilings_by_convex_regular_polygons"
              >Euclidean tilings</a
            >?
          </li>
          <li>
            How do I make one Bézier curve overlap another such that the one "under" doesn't render
            for a bit? Do I need to break the Béziers into two?
          </li>
        </ul>
      </section>
    </main>
    <footer>
      <p>No LLMs were consulted in the making of this site.</p>
      <p>© 2026 Jānis Lībeks</p>
    </footer>

    <script type="module">
      const { createApp, ref, defineComponent } = Vue
      import { TriangleGrid, TrianglePositioner, triSimpleClassName } from './js/triangles.js'
      import { SquareGrid, SquarePositioner, setActiveSquare, sqClassName } from './js/squares.js'
      import {
        triangleTwoPointFactory,
        triangleFourPointFactory,
        twoTileFactory,
        fourCurveFactory,
        fourTileFactory,
        catalan3,
        catalan6,
        threePairs,
      } from './js/triangular-tiles.js'
      import { StraightStroke } from './js/lines.js'
      import { toTransform } from './js/svg-utils.js'

      createApp({
        data() {
          return {
            selected: null,
            grid: new SquarePositioner(
              { x: 0, y: 0 },
              new SquareGrid({
                nX: 30,
                nY: 15,
              }),
              100,
            ).randomize([0, 1]),
          }
        },
        methods: {
          sqClassName,
          setActiveSquare,
          toTransform,
        },
      }).mount('#square-grid-two-tile')

      createApp({
        data() {
          return {
            selected: null,
            grid: new SquarePositioner(
              { x: 0, y: 0 },
              new SquareGrid({
                nX: 30,
                nY: 15,
              }),
              100,
            ).randomize([0, 1, 2, 3, 4, 5, 6]),
          }
        },
        methods: {
          sqClassName,
          toTransform,
        },
      }).mount('#square-grid-five-tile')

      createApp({
        data() {
          return {
            selected: null,
            grid: new TrianglePositioner({
              padding: { x: 200, y: 20 },
              grid: new TriangleGrid({
                nB: 18,
                nY: 5,
              }),
              size: 100,
              data_range: 3,
            }).randomize(),
          }
        },
        methods: {
          triClassName: triSimpleClassName,
          toTransform,
          click: function (event) {
            const tri_data = event.target.parentElement.parentElement.parentElement.dataset.tri
            this.grid.increaseTriangleData(tri_data)
          },
        },
      }).mount('#triangle-grid-three-tile')

      createApp({
        data() {
          return {
            selected: null,
            grid: new TrianglePositioner({
              padding: { x: 100, y: 0 },
              grid: new TriangleGrid({
                nB: 26,
                nY: 7,
              }),
              size: 100,
              data_range: 5,
            }).randomize(),
          }
        },
        methods: {
          triClassName: triSimpleClassName,
          toTransform,
          click: function (event) {
            const tri_data = event.target.parentElement.parentElement.parentElement.dataset.tri
            this.grid.increaseTriangleData(tri_data)
          },
        },
      }).mount('#triangle-grid-two-tile')

      createApp({
        data() {
          return {
            notch: 1 / 3,
          }
        },
        methods: {
          // triClassName: triSimpleClassName,
          // toTransform,
          StraightStroke,
        },
        computed: {
          points() {
            return triangleTwoPointFactory(100, this.notch)
          },
        },
      }).mount('#triangle-two-notch-points')

      createApp({
        data() {
          return {
            tiles: catalan3,
            notch: 1 / 3, // controled by input slider
          }
        },
        methods: {
          toTransform,
        },
        components: { twoTileFactory },
      }).mount('#tile-5-listing')

      createApp({
        data() {
          return {
            selected: null,
            grid: new TrianglePositioner({
              padding: { x: 100, y: 0 },
              grid: new TriangleGrid({
                nB: 26,
                nY: 7,
              }),
              size: 100,
              data_range: catalan3.length,
            }).randomize(),
            tiles: catalan3,
            notch: 1 / 3,
          }
        },
        methods: {
          triClassName: triSimpleClassName,
          toTransform,
          click: function (event) {
            const tri_data = event.target.parentElement.parentElement.parentElement.dataset.tri
            this.grid.increaseTriangleData(tri_data)
          },
        },
        components: { twoTileFactory },
      }).mount('#triangle-grid-two-bezier-tile')

      createApp({
        data() {
          return {
            tiles: threePairs,
          }
        },
        methods: {
          toTransform,
        },
        components: { twoTileFactory },
      }).mount('#tile-15-listing')

      createApp({
        data() {
          return {
            selected: null,
            grid: new TrianglePositioner({
              padding: { x: 100, y: 0 },
              grid: new TriangleGrid({
                nB: 26,
                nY: 7,
              }),
              size: 100,
              data_range: threePairs.length,
            }).randomize(),
            tiles: threePairs,
          }
        },
        methods: {
          triClassName: triSimpleClassName,
          toTransform,
          click: function (event) {
            const tri_data = event.target.parentElement.parentElement.parentElement.dataset.tri
            this.grid.increaseTriangleData(tri_data)
          },
        },
        components: { twoTileFactory },
      }).mount('#triangle-grid-fifteen-bezier-tile')

      createApp({
        data() {
          return {
            notch1: 1 / 5,
            notch2: 3 / 5,
          }
        },
        methods: {
          StraightStroke,
        },
        computed: {
          points() {
            return triangleFourPointFactory(100, this.notch1, this.notch2)
          },
        },
      }).mount('#triangle-four-notch-points')

      createApp({
        data() {
          return {
            notch1: 1 / 5,
            notch2: 3 / 5,
          }
        },
        components: { fourCurveFactory },
        methods: {
          StraightStroke,
        },
        computed: {
          points() {
            return triangleFourPointFactory(100, this.notch1, this.notch2)
          },
        },
      }).mount('#four-notch-examples-1')

      createApp({
        data() {
          return {
            notch1: 1 / 5,
            notch2: 3 / 5,
          }
        },
        components: { fourCurveFactory },
        methods: {
          StraightStroke,
        },
        computed: {
          points() {
            return triangleFourPointFactory(100, this.notch1, this.notch2)
          },
        },
      }).mount('#four-notch-examples-2')

      createApp({
        data() {
          return {
            catalan6,
          }
        },
        components: { fourTileFactory },
        methods: {
          toTransform,
        },
      }).mount('#triangle-grid-132-tiles')

      const gr = new TrianglePositioner({
        padding: { x: 100, y: 0 },
        grid: new TriangleGrid({
          nB: 26,
          nY: 9,
        }),
        size: 100,
        data_range: 132,
      }).randomize()
      createApp({
        data() {
          return {
            selected: null,
            grid: gr,
            catalan6,
            notch1: 1 / 5,
            notch2: 3 / 5,
          }
        },
        methods: {
          triClassName: triSimpleClassName,
          toTransform,
          click: function (event) {
            const tri_data = event.target.parentElement.parentElement.parentElement.dataset.tri
            this.grid.increaseTriangleData(tri_data)
          },
        },
        components: { fourTileFactory },
      }).mount('#triangle-grid-132-truchet')
    </script>
  </body>
</html>
